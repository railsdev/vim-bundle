task :set_compliance_data => :environment do
	Rake::Task["clear_compliance_data"].invoke
	puts "Setting compliance data -- Invoked....."
	puts "Creating Consumer Medication Data......"
	Rake::Task["consumer_medication_data"].invoke
	puts "Consumer Medication Data Created......"
	puts "Creating Reminders......"
	Rake::Task["create_reminders"].invoke
	puts "Reminders Created......"
	puts "Creating Consumer Compliance Data......"
	Rake::Task["create_compliance_data"].invoke
	puts "Consumer Compliance Data Created......"

	puts "Setting compliance data -- Done"

end

task :clear_compliance_data => :environment do
	puts "Clearing data......"

	#ConsumerMedication.delete_all
	puts "Consumer Medications Deleted......"
	Reminder.delete_all
	puts "Reminders Deleted......"
	ScheduledReminder.delete_all
	puts "Scheduled Reminders Deleted......"
	#ConsumerCompliance.delete_all
	#puts "Consumer Compliances Deleted......"

	puts "Data Cleared..."
end

task :create_compliance_data => :environment do
	Reminder.where(:is_active => true).each do |reminder|
		count = 0
		reminder.scheduled_reminders.where(:is_active => true).each do |scr|
			status = ""
			responded_at = ""
			if count < 3
				status = COMPLIANCE_STATUS_TAKEN
				responded_at = scr.run_at + 10.minutes
			else count >=3 && count < 10
				status = COMPLIANCE_STATUS_SKIPPED
				responded_at = scr.run_at + 2.days
			# else
			# 	status = REMINDER_STATUS_PENDING
			# 	responded_at = scr.run_at + 2.days
			end

			ConsumerCompliance.create(:consumer_id => reminder.consumer_id, 
									  :consumer_medication_id => reminder.consumer_medication_id,
									  :reminder_triggered_at => scr.run_at,
									  :status => status, 
									  :reminder_responded_at => responded_at
									  )
			count += 1
		end

	end
end

task :consumer_medication_data => :environment do
	ConsumerMedication.delete_all
	Consumer.all.each do |c|
		drugs = Drug.where(:is_active => true).limit(3)
		drugs.each{ |d| d.consumer_medications.where(:consumer_id => c.id, :dose_quantity => "1", :dose_unit => "mg", :is_active => true ).create }
	end
end

task :create_reminders => :environment do
	Consumer.all.each do |consumer|
		count = 0
		consumer.consumer_medications.each do |consumer_medication|
			if count == 0
				params = { :consumer_id => consumer.id,
					:consumer_medication_id => consumer_medication.id,
					:reminder => {:fq_type => REMINDER_FREQUENCY_DAILY },
					:fq_type_daily => "3",
					:fq_time => ["11:15 am", "02:30 pm", "03:30 pm", "", "", "" ],
					:dose_quantity => "3.0",
					:dose_unit => "mg",
				}
			elsif count == 1
				params = { :consumer_id => consumer.id,
					:consumer_medication_id => consumer_medication.id,
					:reminder => {:fq_type => REMINDER_FREQUENCY_MONTHLY},
					:fq_month => ["1", "4"],
					:fq_day=> ["15"],
					:fq_time => ["10:30 am" ],
					:dose_quantity => "1.0",
					:dose_unit => "mg",
				}
			else
				params = { :consumer_id => consumer.id,
					:consumer_medication_id => consumer_medication.id,
					:reminder => {:fq_type => REMINDER_FREQUENCY_YEARLY},
					:fq_month => ["2", "4"],
					:fq_day => ["8"],
				    :fq_time => ["10:00 am"],
					:dose_quantity => "3.0",
					:dose_unit => "mg",
				}

			end
			@reminders = queue_up_schedules params
			if @reminders.all? {|x| x.valid? }
				consumer_medication.update(dose_quantity: params[:dose_quantity].calculate, dose_unit: params[:dose_unit])
			end
			count += 1
		end
	end
end


def queue_up_schedules(params)
	reminders = []
	if params[:reminder][:fq_type] == 'Daily' 
		params[:fq_time] = params[:fq_time].take(params[:fq_type_daily].to_i) # COnsider only the number of fields selected by user out of 6 slots
		params[:fq_time].delete_if {|c| c.empty? }
		fq_time = params[:fq_time].delete_at(0)
		if !params[:fq_time].blank?
		reminders << reminder = build_reminders_by_time(fq_time, params) # create parent reminder

        params[:fq_time].each do |time| 
          reminders << build_reminders_by_time(time, reminder, params) # build all child reminders
      	end

		else
			reminders << build_reminders_by_time(fq_time, params)
		end

	elsif ['Monthly', 'Weekly'].include? params[:reminder][:fq_type]
		# params[:fq_day] && !params[:fq_day].blank? && params[:fq_day].is_a?(String) ? fq_day = params[:fq_day] : fq_day = params[:fq_day].delete_at(0)
		fq_day = params[:fq_day].delete_at(0)
		if !params[:fq_day].blank?

	        reminders << reminder = build_reminders_by_day(fq_day, params) # create parent reminder

	        params[:fq_day].each do |day| 
	          reminders << build_reminders_by_day(day, reminder, params) # build all child reminders
	     	end

	  	else
	  		reminders << build_reminders_by_day(fq_day, params)
	  	end

	elsif params[:reminder][:fq_type] == 'Yearly'
		fq_month = params[:fq_month].delete_at(0)
		if !params[:fq_month].blank?

	        reminders << reminder = build_reminders_by_month(fq_month, params) # create parent reminder

	        params[:fq_month].each do |month| 
	          reminders << build_reminders_by_month(month, reminder, params) # build all child reminders
	      	end

		else
			reminders << build_reminders_month(fq_month, params)
		end
	else
  		# params[:fq_time] = params[:start_time]

      case params[:reminder][:fq_type]

      when 'Every X days', 'Every X hours'
      	params[:fq_time] = params[:start_time]
      	fq_time =  DateTime.strptime(params[:fq_time], "%m/%d/%Y %I:%M %p") #if params[:fq_time]
      	!params[:fq_time].blank? ? reminders << reminder = build_reminders_by_time(fq_time, params) : reminders << build_reminders_by_time(fq_time, params)

      when 'Every X weeks', 'Every X months'
      	fq_day = DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p").wday
      	params[:fq_day] = fq_day.to_s
      	reminders << build_reminders_by_day(fq_day, reminder, params)

      when 'Every X years'
      	fq_month = DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p").month
      	fq_day = DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p").wday
      	params[:fq_month] = fq_month
      	params[:fq_day] = fq_day
      	reminders << build_reminders_by_month(fq_month, reminder, params)
      end

	end

	reminders
end


def build_reminders_by_time(fq_time, parent=nil, params)
	return Reminder.create reminder_by_time_params(fq_time, parent, params) 

end

def build_reminders_by_day(fq_day, parent=nil, params)
	return Reminder.create reminder_by_day_params(fq_day, parent, params) 
end

def build_reminders_by_month(fq_month, parent=nil, params)
	return Reminder.create reminder_by_month_params(fq_month, parent, params) 
end

def reminder_by_time_params(fq_time, parent=nil, params)
	return {:fq_type => params[:reminder][:fq_type], 
		:interval    => params[:interval],
		:fq_day      => params[:fq_day],
		:fq_month    => params[:fq_month],
		:fq_time     => fq_time,
		:start_time  => params[:start_time] && !params[:start_time].blank? ? DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p") : params[:start_time],
		:parent_id   => parent.try(:id),
		:consumer_id => params[:consumer_id],
		:consumer_medication_id => params[:consumer_medication_id] 
	}

end


def reminder_by_day_params(fq_day, parent=nil, params)
	return {:fq_type => params[:reminder][:fq_type], 
		:interval    => params[:interval],
		:fq_day      => fq_day.to_i,
		:fq_month    => params[:fq_month],
		:fq_time     => params[:fq_time] ? params[:fq_time].first.to_time : DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p"),
		:start_time  => params[:start_time] && !params[:start_time].blank? ? DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p") : params[:start_time],
		:parent_id   => parent.try(:id),
		:consumer_id => params[:consumer_id],
		:consumer_medication_id => params[:consumer_medication_id] 
	}

end

def reminder_by_month_params(fq_month, parent=nil, params)
	return {:fq_type     => params[:reminder][:fq_type], 
		:interval    => params[:interval],
		:fq_day      => params[:fq_day].first.to_i,
		:fq_month    => fq_month,
		:start_time  => params[:start_time] && !params[:start_time].blank? ? DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p") : params[:start_time],
		:fq_time     => params[:fq_time] ? params[:fq_time].first.to_time : DateTime.strptime(params[:start_time], "%m/%d/%Y %I:%M %p"),
		:parent_id   => parent.try(:id),
		:consumer_id => params[:consumer_id],
		:consumer_medication_id => params[:consumer_medication_id] 
	}

end
