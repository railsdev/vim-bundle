require "test_helper"

class EveryXYearsReminderTest < ActiveSupport::TestCase

    def setup
      Reminder.destroy_all
      ScheduledReminder.destroy_all
      @reminder = Reminder.create( fq_type:    'Every X years', 
                                   fq_day:     3, 
                                   fq_time:    Time.now,
                                   fq_month:   6,
                                   start_time: Time.now,
                                   consumer_id:1, 
                                   consumer_medication_id: 1, 
                                   interval:   2 )
      @reminder.reload
    end

    def test_reminders_default_values
      assert_equal "Yearly", @reminder.fq_type
      assert @reminder.is_active
      assert @reminder.is_scheduled
    end


    # TODO: Setup logic to identify completed list of scheduled reminders
    def test_last_schedule_of_reminder
      assert_equal @reminder.last_schedule_on, @reminder.scheduled_reminders.order('run_at').last.run_at
    end

    def test_destroy
      reminder_id = @reminder.id
      @reminder.destroy
      assert_empty ScheduledReminder.where(reminder_id: reminder_id).to_a
    end

    # TODO: Bad way.. need to refactor
    def test_day_of_scheduled_reminders
      @reminder.scheduled_reminders.each{|x| assert_equal x.run_at.mday, @reminder.fq_day }
    end

    # TODO: Bad way.. need to refactor
    def test_month_of_scheduled_reminders
      @reminder.scheduled_reminders.each{|x| assert_equal x.run_at.month, @reminder.fq_month }
    end

    # TODO: Bad way.. need to refactor
    def test_time_of_schedule_reminders
      @reminder.scheduled_reminders.each{|x| assert_equal x.run_at.hour, @reminder.fq_time.hour}
      @reminder.scheduled_reminders.each{|x| assert_equal x.run_at.min, @reminder.fq_time.min}
    end

    def test_different_of_time_between_scheduled_reminders
      @reminder.scheduled_reminders.order('run_at').to_a.each_cons(2).each{|a, b| assert_equal (b.run_at.year - a.run_at.year ), @reminder.interval }
    end


end
